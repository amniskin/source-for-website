%clj
  (ns book.sicp.texts.ch2sect1
    (:require-macros [tailrecursion.hoplon.markdown :refer [md]])
    (:require        [tailrecursion.hoplon.markdown :as md]
                     [book.sicp.book-data        :as data]))

%sexp
  defelem content [_ _]
  %div
    %data/sect{:title "Introduction to Data Abstraction"}
      %md
        In [section 1.1.8](#!/sicp/ch/1/sect/1/sub/8/), we noted that a
        procedure used as an element in creating a more complex procedure could
        be regarded not only as a collection of particular operations but also
        as a procedural abstraction. That is, the details of how the procedure
        was implemented could be suppressed, and the particular procedure
        itself could be replaced by any other procedure with the same overall
        behavior. In other words, we could make an abstraction that would
        separate the way the procedure would be used from the details of how
        the procedure would be implemented in terms of more primitive
        procedures. The analogous notion for compound data is called *data
        abstraction*. Data abstraction is a methodology that enables us to
        isolate how a compound data object is used from the details of how it
        is constructed from more primitive data objects.

        The basic idea of data abstraction is to structure the programs that
        are to use compound data objects so that they operate on "abstract
        data." That is, our programs should use data in such a way as to make
        no assumptions about the data that are not strictly necessary for
        performing the task at hand. At the same time, a "concrete" data
        representation is defined independent of the programs that use the
        data. The interface between these two parts of our system will be a set
        of procedures, called *selectors* and *constructors*, that implement
        the abstract data in terms of the concrete representation. To
        illustrate this technique, we will consider how to design a set of
        procedures for manipulating rational numbers.

    %data.subsect{:title "Example: Arithmetic Operations for Rational Numbers"}
      %md
        Suppose we want to do arithmetic with rational numbers. We want to be
        able to add, subtract, multiply, and divide them and to test whether
        two rational numbers are equal.

        Let us begin by assuming that we already have a way of constructing a
        rational number from a numerator and a denominator. We also assume
        that, given a rational number, we have a way of extracting (or
        selecting) its numerator and its denominator. Let us further assume
        that the constructor and selectors are available as procedures:

        - `(make-rat <n> <d>)` returns the rational number whose numerator is
        the integer `<n>` and whose denominator is the integer `<d>`.  -
        `(numer <x>)` returns the numerator of the rational number `<x>`.
        - `(denom <x>)` returns the denominator of the rational number `<x>`.

        We are using here a powerful strategy of synthesis: *wishful thinking*.
        We haven't yet said how a rational number is represented, or how the
        procedures `numer`, `denom`, and `make-rat` should be implemented. Even
        so, if we did have these three procedures, we could then add, subtract,
        multiply, divide, and test equality by using the following relations:

        $$\begin{align*}
        \frac{n_1}{d_1}+\frac{n_2}{d_2}=&\frac{n_1d_2+n_2d_1}{d_1d_2}
        \\\\\frac{n_1}{d_1}-\frac{n_2}{d_2}=&\frac{n_1d_2-n_2d_1}{d_1d_2}
        \\\\\frac{n_1}{d_1}\cdot\frac{n_2}{d_2}=&\frac{n_1n_2}{d_1d_2}
        \\\\\frac{n_1}{d_1}/\frac{n_2}{d_2}=&\frac{n_1d_2}{n_2d_1}
        \\\\\frac{n_1}{d_1}=\frac{n_2}{d_2}\iff& n_1d_2=n_2d_1\end{align*}$$

        We can express these rules as procedures:

        ```clj
        (defn add-rat [x y]
          (make-rat (+ (* (numer x) (* denom y))
                       (* (numer y) (* denom x)))
                    (* (denom x) (denom y))))
        (defn sub-rat [x y]
          (make-rat (- (* (numer x) (* denom y))
                       (* (numer y) (* denom x)))
                    (* (denom x) (denom y))))
        (defn mul-rat [x y]
          (make-rat (* (numer x) (numer y))
                    (* (denom x) (denom y))))
        (defn div-rat [x y]
          (make-rat (* (numer x) (denom y))
                    (* (denom x) (numer y))))
        (defn equal-rat? [x y]
          (= (* (numer x) (denom y))
             (* (numer y) (denom x))))
        ```

        Now we have the operations on rational numbers defined in terms of the
        selector and constructor procedures `numer`, `denom`, and `make-rat`.
        But we haven't yet defined these. What we need is some way to glue
        together a numerator and a denominator to form a rational number.

    %data.ssub{:title "Pairs (or Lists, for Us)"}
      %md
        To enable us to implement the concrete level of our data abstraction,
        our language provides a compound structure abstraction called a
        *sequential object*. These sequential objects are really just anything
        that has a concept of a *first* item and a *rest* of the items. Hence,
        a sequential object is any object which allows use of the `first` and
        `rest` protocols (kind of like procedures, except their actual
        execution may be different from data type to data type). One example of
        a sequential object -- the one we will be using instead of the "pairs"
        they use for this section in Scheme -- is called a *list*. Lists can be
        constructed via the procedure `list` like so `(list 1 2 3)` gives you a
        list containing 1, 2, and 3 as its elements. So `(first (list 1 2 3))`
        would return `1`, and `(rest (list 1 2 3))` returns `(2 3)`, which is
        to say the list containing 2 and 3 as its elements. To check if what
        we've been given is indeed a list, we can use the procedure `list?`
        like so: `(list? (rest (list 1 2 3)))`. Lists are actually made via
        pairs (as will be described later in this section), but all of that is
        under the hood. Lists can also be constructed from old lists with the
        procedure `conj`.<<We should note that since these lists are immutable,
        the only way to "edit" a list would be to create a new one with the
        desired changes and then destroy the old one.  While this may seem
        unfortunate at first, it is actually quite a desireable feature when
        dealing with concurrency.>> This procedure takes two or more arguments,
        a sequential object and any number of values to append to the
        sequential object, then returns a sequential object of the same type
        with the values appended in whatever method appropriate to that
        sequential object in the order they appear. We will see later that
        lists are constructed in such a way that prepending is very cheap, so
        `conj` does exactly that. Hence, `(conj (list 1 2 3) 4)` returns `(4 1
        2 3)`, and `(conj (list 1 2 3) 4 5)` returns `(5 4 1 2 3)` (remember
        that they are prepended in the order they appear!).
        
        In Scheme, however, their building block is the *pair*, wich can be
        constructed via the primitive procedure `cons` (which also works in
        Clojure... kinda) and has procedures `car` and `cdr` for obtaining the
        first and second values of the pair respectively.<<The name `cons`
        stands for "construct." The names `car` and `cdr` derive from the
        original implementation of Lisp on the IBM 704. That machine had an
        addressing scheme that allowed one to reference the "address" and
        "decrement" parts of a memory location. `car` stands for "Contents of
        Address part of Register" and `cdr` (pronounced "could-er") stands for
        "Contents of Decrement part of Register.">> Thus, we in Scheme, we
        would be able to use `cons`, `car`, and `cdr` as follows: 
        
        ```scm
        (define x (cons 1 2))
        ```

        Go ahead and try this in Clojure (can you translate that?)
      
      %data.q-a
        ```clj
        (def x (cons 1 2))
        ```

      %md  
        If you tried the previous example. you probably got an error. That is
        because Clojure implements `cons` differently. If we try 
        
        ```clj
        (def x (cons 1 (cons 2 nil)))
        ```
        
        Then we shouldn't get any errors. The reason is that the second
        argument of `cons` must be sequential object (or `nil`). Either way, we
        will not be using `cons` for our discourse in this chapter, but rather
        the procedures `list` and `conj`, which are more general anyway. Along
        with `first` and `rest`, lists also have `second` and `nth` which give
        you exactly what you'd expect, the second and the nth values in the
        list. So,

        ```clj
        (def x (list 1 2))
        (first x)
        1
        (second x)
        2
        ```

        Notice that a list is a data object that can be given a name and
        manipulated, just like a primitive data object. Moreover, `list` can be
        used to form pairs whose elements are pairs, and so on:

        ```clj
        (def x (list 1 (list 2 nil)))
        (def y (list 3 (list 4 nil)))
        (def z (list x y))

        (first (first z))
        1
        (first (second z))
        3
        ```

        In [section 2.2](#!/sicp/ch/2/sect/2/) we will see how this ability to
        combine pairs means that pairs can be used as general-purpose building
        blocks to create all sorts of complex data structures. The single
        compound-data primitive *pair*, implemented in Scheme by the procedures
        `cons`, `car`, and `cdr`, is the only glue we need. Data objects
        constructed from pairs are called *list-structured* data. In fact, we
        will explore how lists are acutally implemented in Clojure and we will
        see that it is very similar to Scheme in that respect. For now, let's
        pretend like our `list`s are really pairs (for the purposes of learning
        the lessons meant to be learned in the following sections).

    %data.ssub{:title "Representing Rational Numbers"}
      %md
        Pairs offer a natural way to complete the rational-number system.
        Simply represent a rational number as a pair of two integers: a
        numerator and a denominator. Then `make-rat`, `numer`, and `denom` are
        readily implemented as follows:<<Another way to define the selectors
        and constructor is `(define make-rat cons)` `(define numer car)`
        `(define denom cdr)` The first definition associates the name
        `make-rat` with the value of the expression `cons`, which is the
        primitive procedure that constructs pairs. Thus `make-rat` and `cons`
        are names for the same primitive constructor. Defining selectors and
        constructors this way is efficient: Instead of `make-rat` *calling*
        `cons`, `make-rat` *is* `cons`, so there is only one procedure called,
        not two, when `make-rat` is called. On the other hand, doing this
        defeats debugging aids that trace procedure calls or put breakpoints on
        procedure calls: You may want to watch `make-rat` being called, but you
        certainly don not want to watch every call to `cons`.>>

        ```scm
        (define (make-rat n d) (list n d))
        (define (numer x) (first x))
        (define (denom x) (second x))
        ```

        Also, in order to display the results of our computations, we can print
        rational numbers by printing the numerator, a slash, and the
        denominator.<<Note that `print` and `println` (there are others but we
        need not go into them right now) return values. Being as how the values
        are not currently of use to us, we show only what these functions print
        and not what the interpreter prints as the returned values.>>

        ```clj
        (defn print-rat [x]
          (println (numer x) "/" (denom x)))
        ```

        Note that `println` is a function that takes any number of arguments,
        converts them to a string, prints them to the screen followed by a new
        line, then it returns the value `nil` (remember, everything has a value
        in Lisp!).

        Now we can try our rational-number procedures:

        ```clj
        (def one-half (make-rat 1 2))
        (print-rat one-half)
        1/2

        (def one-third (make-rat 1 3))
        (print-rat (add-rat one-half one-third))
        5/6

        (print-rat (mul-rat one-half one-third))
        1/6

        (print-rat (add-rat one-third one-third))
        6/9
        ```

        As the final example shows, our rational-number implementation does not
        reduce rational numbers to lowest terms. We can rememdy this by
        changing `make-rat`. If we have a `gcd` procedure like the one used in
        [section 1.2.5](#!/sicp/ch/1/sect/2/sub/5/) that produces the greatest
        common divisor of two integers, we can use `gcd` to reduce the
        numerator and the denominator to lowest terms before constructing the
        pair:

        ```clj
        (defn make-rat [n d]
          (let [g (gcd n d)]
            (list (/ n g) (/ d g))))
        ```

        Now we have,

        ```clj
        (print-rat (add-rat one-third one-third))
        2/3
        ```
        as desired. This modification was accomplished by changing the
        constructor `make-rat` without changing any of the procedures (such as
        `add-rat` and `mul-rat`) that implement the actual operations.

    %data.exercises
      %data.exercise
        %md
          Define a better version of `make-rat` that handles both positive and
          negative arguments. `make-rat` should normalize the sign so that if
          the rational number is positive, both the numerator and denominator
          are positive, and if the rational number is negative, only the
          numerator is negative.
        
        %data.q-a
          %md
            ```clj
            (defn make-rat [n d]
              (let [doit #(let [g (gcd %1 %2)]
                            (list (/ %1 g) (/ %2 g)))]
                (if (> (* n d) 0)
                    (doit (Math/abs n) (Math/abs d))
                    (doit (- (Math/abs n)) (Math/abs d)))))
            ```

    %data.subsect{:title "Abstraction Barriers"}
      %md
        Before continuing with more examples of compound data and data
        abstraction, let us consider some of the issues raised by the
        rational-number example. We defined the rational-number operations in
        terms of a constructor `make-rat` and selectors `numer` and `denom`. In
        general, the underlying idea of data abstraction is to identify for
        each type of data object the basic set of operations in terms of which
        all manipulations op data objects of that type will be expressed, and
        then to use only those operations in manipulating the data.

        We can envision the structure of the rational-number system as shown in
        [figure 2.1](#!/sicp/ch/2/fig/1/). The horizontal lines represent
        *abstraction barriers* that isolate different "levels" of the system.
        At each level, the barrier separates the programs (above) that use th
        edata abstraction from the programs (below) that implement the data
        abstraction. Programs that use rational numbers manipulate them solely
        in terms of the procedures supplied "for public use" by the
        rational-number package: `add-rat`, `sub-rat`, `mul-rat`, `div-rat`,
        `numer`, and `denom`, which themselves are implemented in terms of
        lists. The details of how lists are implemented are irrelevant to the
        rest of the rational-number package so long as lists can be manipulated
        by the use of `list`, `first`, and `second`. In effect, procedures at
        each level are the interfaces that define the abstraction barriers and
        connect the different levels.

      %data.fig{:footer "Data-abstraction barriers in the rational-number package."}

      %md
        This simple idea has many advantages. One advantage is that it makes
        programs much easier to maintain and modify. Any complex data structure
        can be represented in a variety of ways within primitive data
        structures provided by a programming language. Of course, the choice of
        representation influences the programs that operate on it; thus, if the
        representation were to be changed at some later time, all such programs
        might have to be modified accordingly. This task could be
        time-consuming and expensive in the vase of large programs unless the
        dependence on the representation were to be confined by design to a
        very few program modules.

        For example, an alternate way to address the problem of reducing
        rational numbers to lowest terms is to perform the reduction whenever
        we acces the parts of a rational number, rather than when we construct
        it. This leads to different constructor and selector procedures:

        ```clj
        (defn make-rat [n d]
          (list n d))
        (defn numer [x]
          (let [g (gcd (first x) (second x))]
            (/ (first x) g)))
        (defn denom [x]
          (let [g (gcd (first x) (second x))]
            (/ (second x) g)))
        ```

        The difference between this implementation and the previous one lies in
        when we compute the `gcd`. If in our typical use of rational numbers we
        access the numerators and denominators of the same rational numbers
        many times, it would be preferable to compute the `gcd` when the
        rational numbers are constructed. If not, we may be better off waiting
        until access time to compute the `gcd`. In any case, when we change
        from one representation to the other, the procedures `add-rat`,
        `sub-rat` and so on do not have to be modified at all.

        Constraining the dependence on the representation to a few interface
        procedures helps us design programs as well as modify them, because it
        allows us to maintain the flexibility to consider alternate
        implementations. To continue with our simple example, suppose we are
        designing a rational-number package and we can't decide initially
        whether to perform the `gcd` at construction time or at selection time.
        The data-abstraction methodology gives us a way to defer that decision
        without losing the ability to make progress on the rest of the system.

    %data.exercises
      %data.exercise
        %md
          Consider the problem of representing line segments in a plane. Each
          segment is represented as a pair of points: a starting point and an
          ending point. Define a constructor `make-segment` and selectors
          `start-segment` and `end-segment` that define the representation of
          segments in terms of points. Furthermore, a point can be represented
          as a pair of numbers: the \\(x\\) coordinate and the \\(y\\)
          coordinate. Accordingly, specify a constructor `make-point` and
          selectors `x-point` and `y-point` that define this representation.
          Finally, using your selectors and constructors, define a procedure
          `midpoint-segment` that takes a line segment as argument and returns
          its midpoint (the point whose coordinates are the average of the
          coordinates of the endpoints). To try your procedures, you'll need a
          way to print points:

          ```clj
          (defn print-point [p]
            (println "(" (x-point p) "," (y-point p) ")"))
          ```

        %data.q-a
          %md
            ```clj
            (defn make-point [x y]
              (list x y))
            (defn x-point [p]
              (first p))
            (defn y-point [p]
              (second p))
            (defn make-segment [p q]
              (list p q))
            (defn start-segment [l]
              (first l))
            (defn end-segment [l]
              (second l))
            ```

            Once we have those,

            ```clj
            (defn midpoint-segment [l]
              (let [p  (start-segment l)
                    q  (end-segment l)
                    x1 (x-point p)
                    y1 (y-point p)
                    x2 (x-point q)
                    y2 (y-point q)]
                (make-point (average x1 x2) (average y1 y2))))
            ```

      %data.exercise
        %md
          Implement a representation for rectangles in a plane. (Hint: you may
          want to make use of [exercise 2.2](#!/sicp/ch/2/ex/2/) In terms of
          your constructors and selectors, create procedures that compute the
          perimeter and the area of a given rectangle. Now implement a
          different representation for rectangles. Can you design your system
          with suitable abstraction barriers, so that the same perimeter and
          area procedures will work using either representation?

        %data.q-a
          %md
            Assuming we are given coordinates of an actual rectangle (so that
            we don't have to use the Pythagorean theorem or some other method
            to confirm that the points are what they claim to be), will
            simplify our lives considerably. Since any rectangle is determined
            by three of its vertices, we can assume that we are given three
            sequentially adjacent vertices.

            ```clj
            (defn make-rectangle [a b c]
              (list a b c))
            ```

            Then, we realize that in order to compute the area and perimeter,
            we need to know the length and width of the rectangle. So, let's
            write a separate procedure to do that. But before we do that, it
            might be a good idea to have a procedure that can find the length
            of a segment (we could do without this procedure, but it seems like
            a useful procedure to have if we are to be working with segments,
            so why not allow ourselves this tool?).

            ```clj
            (defn length-segment [l]
              (let [p  (start-segment l)
                    q  (end-segment l)
                    x1 (x-point p)
                    y1 (y-point p)
                    x2 (x-point q)
                    y2 (y-point q)]
                (Math/sqrt (+ (square (- x1 x2))
                              (square (- y1 y2))))))
            ```

            Good, now we can move on. I'm not sure if it would be useful to
            define a global procedure to get the sides of a rectangle as
            line-segments, but if it gets in the way, we can use a `let`
            binding instead. For now, let's define it globally.

            ```clj
            (defn side1-rectangle [r]
              (make-segment (first r) (second r)))
            (defn side2-rectangle [r]
              (make-segment (second r) (nth r 2)))
            ```

            Now we're ready to make our area and perimeter procedures.

            ```clj
            (defn area-rectangle [r]
              (* (length-segment (side1-rectangle r))
                 (length-segment (side2-rectangle r))))
            (defn perimeter-rectangle [r]
              (* 2 (+ (length-segment (side1-rectangle r))
                      (length-segment (side2-rectangle r)))))
            ```

            Now, if our implementation for rectangles were something different,
            like:

            ```clj
            (defn make-rectangle [a b c]
              (list (list a b) (list b c)))
            ```

            In this representation, we're defining rectangles by their sides
            rather than by their vertices. Let's see how things must change.

            ```clj
            (defn side1-rectangle [r]
              (first r))
            (defn side2-rectangle [r]
              (second r))
            ```

            Then everything else works just fine.

            Note: if we wanted to check to make sure that the points were in
            fact vertices of a rectangle, we could just add an `if` statement
            to our definition of `make-rectangle` such that if it passes the
            Pythagorean test 
            
            ```clj
            (= (square (diagonal-rectangle r)) 
               (+ (square (side1-rectangle r)) 
                  (square (side2-rectangle r))))
            ```

            Where `diagonal-rectangle` would be defined in the necessary way to
            get what should be the diagonal of the rectangle.

    %data.subsect{:title "What is Meant by Data?"}
      %md
        We began the rational-number implementation in [section
        2.1.1](#!/sicp/ch/2/sect/1/sub/1/) by implementing the rational-number
        operations `add-rat`, `sub-rat`, and so on in terms of three
        unspecified procedures: `make-rat`, `numer`, and `denom`. At that
        point, we could think of the operations as being defined in terms of
        data objects -- numerators, denominators, and rational numbers -- whose
        behavior was specified by the latter three procedures.

        But exactly what is meant by *data*? It is not enough to say "whatever
        is implemented by the given selectors and constructors." Clearly, not
        every arbitrary set of three procedures can serve as an appropriate
        basis for the rational-number implementation. We need to guarantee
        that, if we construct a rational number `x` from a pair of integers `n`
        and `d`, then extracting the `numer` and the `denom` of `x` and
        dividing them should yield the same result as dividing `n` by `d`. In
        other words, `make-rat`, `numer`, and `denom` must satisfy the
        condition that, for any integer `n` and any non-zero integer `d`, if
        `x` is `(make-rat n d)`, then

        $$\frac{\text{(numer x)}}{\text{(denom x)}}=\frac{\text{n}}{\text{d}}$$

        In fact, this is the only condition `make-rat`, `numer` and `denom`
        must fulfill in order to form a suitable basis for a rational-number
        representation. In general, we can think of data as defined by some
        collection of selectors and constructors, together with specified
        conditions that these procedures must fulfill in order to be a valid
        representation.<<Surprisingly, this idea is very difficult to formulate
        rigorously. There are two approaches to giving such a formulation. One,
        pioneered by C. A. R. Hoare (1972), is known as the method of *abstract
        models*. It formalizes the "procedures plus conditions" specification
        as outlined in the rational-number example above. Note that the
        condition on the rational-number representation was stated in terms of
        facts about integers (equality and division). In general, abstract
        models define new kinds of data objects in terms of previously defined
        types of data objects. Assertions about data objects can therefore be
        checked by reducing them to assertions about previously defined data
        objects. Another approach, introduced by Zilles at MIT, by Goguen,
        Thatcher, Wagner, and Wright at IBM (see Thatcher, Wagner, and Wright
        1978), and by Guttag at Toronto (see Guttag 1977), is called *algebraic
        specification*. It regards the "procedures" as elements of an abstract
        algebraic system whose behavior is specified by axioms that correspond
        to our "conditions," and uses the techniques of abstract algebra to
        check assertions about data objects. Both methods are surveyed in the
        paper by Liskov and Zilles (1975).>>

        This point of view can serve to define not only "high-level" data
        objects, such as rational numbers, but lower-level objects as well.
        Consider the notion of a list or a pair (a list of two elements), which
        we used in order to define our rational numbers. We never actually said
        what these were, only that the language supplied procedures `list`,
        `first`, and `second` for operating on them. But the only thing we need
        to know about these three operations is that if we glue two objects
        together using `cons` or `list`, we can retrieve the objects using
        `first`, `rest`, `second` and `nth`. That is, the operations satisfy
        the condition that, for any objects `x` and `y`, if `z` is `(list x y)`
        then `(first z)` is `x` and `(second z)` is `y`. Indeed, we mentioned
        that these three procedures are included as primitives in our language.
        However, any triple of procedures that satisfies the above condition
        can be used as the basis for implementing pairs. This point is
        illustrated strikingly by the fact that we could implement `cons`,
        `first`, and `second` for lists without using any data structures at
        all but only using procedures. Here are the definitions:

        ```clj
        (defn cons [x y]
          (let [dispatch (fn [m] (cond (= m 0) x
                                       (= m 1) y
                                       :else (throw (Exception. "Argument not 0 or 1 -- CONS" m))))]
            dispatch))
        
        (defn car [x] (z 0))

        (defn cdr [x] (z 1))
        ```

        In the above definitions I used `cons`, `car`, and `cdr` instead of
        `list`, `first`, and `second` simply because I like to not deviate from
        the book whenever possible and it doesn't necessarily add anything to
        deviate. On the down side (of deviating from the text), this
        construction would not work if we used lists because lists can have any
        number of elements so we'd have to use other methods to make it work.
        We digress...

        This use of procedures corresponds to nothing like our intuitive notion
        of what data should be. Nevertheless, all we need to do to show that
        this is a valid way to represent pairs is to verify that these
        procedures satisfy the condition given above.

        The subtle point to notice is that the value returned by `(cons x y)`
        is a procedure -- namely the internally defined procedure `dispatch`,
        which takes one argument and returns either `x` or `y` depending on
        whether the argument is 0 or 1. Correspondingly, `(car z)` is defined
        to apply `z` to 0. Hence, if `z` is the procedure formed by `(cons x
        y)`, then `z` applied to 0 will yield `x`. Thus, we have shown that
        `(car (cons x y))` yields `x`, as desired. Similarly, `(cdr (cons x
        y))` applies the procedure returned by `(cons x y)` to 1, which returns
        `y`. Therefore, this procedural implementation of pairs is a valid
        implementation, and if we access pairs using only `cons`, `car`, and
        `cdr` we cannot distinguish this implementation from one that uses
        "real" data structures.

        The point of exhibiting the procedural representation of pairs is not
        that our language works this way (Scheme, and Lisp systems in general,
        implement pairs directly, and Clojure implements lists directly as Java
        objects, for efficiency reasons) but that it could work this way. The
        procedural representation, although obscure, is a perfectly adequate
        way to represent pairs, since it fulfills the only conditions that
        pairs need to fulfill. This example also demonstrates that the ability
        to manipulate procedures as objects automatically provides the ability
        to represent compound data. This may seem a curiosity now, but
        procedural representations of data will play a central role in our
        programming repertoire. This style of programming is often called
        message passing, and we will be using it as a basic tool in chapter 3
        when we address the issues of modeling and simulation.

    %data.exercises
      %data.exercise
        %md
          Here is an alternative procedural representation of pairs. For this
          representation, verify that (car (cons x y)) yields x for any objects
          x and y.

          ```clj
          (defn cons [x y]
            (fn [m] (m x y)))
          (defn car [z]
            (z (fn [p q] p)))
          ```

          What is the corresponding definition of `cdr`? (Hint: To verify that
          ths works, make use of the substitution model of [section
          1.1.5](#!/sicp/ch/1/sect/1/sub/5/).)

        %data.q-a
          %md
            ```clj
            (defn cdr [z]
              (z (fn [p q] q)))
            ```

      %data.exercise
        %md
          Show that we can represent pairs of nonnegative integers using only
          numbers and arithmetic operations if we represent the pair \\(a\\)
          and \\(b\\) as the integer that is the product \\(2^a3^b\\).  Give
          the corresponding definitions of the procedures `cons`, `car`, and
          `cdr`.

        %data.q-a
          %md
            ```clj
            (defn cons [x y]
              (* (exp 2 x) (exp 2 y)))
            (defn car [z]
              (loop [a    z
                     accu 0]
                (if (= (mod a 2) 0)
                    (recur (/ a 2) (inc accu))
                    accu)))
            (defn cdr [z]
              (loop [a    z
                     accu 0]
                (if (= (mod a 3) 0)
                    (recur (/ a 3) (inc accu))
                    accu)))
            ```

      %data.exercise
        %md
          In case representing pairs as procedures wasn't mind-boggling enough,
          consider that, in a language that can manipulate procedures, we can
          get by without numbers (at least insofar as nonnegative integers are
          concerned) by implementing 0 and the operation of adding 1 as

          ```clj
          (def zero (fn [f] (fn [x] x)))
          (defn add-1 [n]
            (fn [f] (fn [x] (f ((n f) x)))))
          ```

          This representation is known as *Church numerals*, after its
          inventor, Alanzo Church, the logician who invented the λ calculus.

          Define `one` and `two` directly (not in terms of `zero` and `add-1`).
          (Hint: Use substitution to evaluate `(add-1 zero)`). Give a direct
          definition of the addition procedure + (not in terms of repeated
          application of `add-1`).

        %data.q-a
          %md
            ```clj
            (def one
              (fn [f] (fn [x] (f x))))
            (def two
              (fn [f] (fn [x] (f (f x)))))
            ```

            As for addition, first let's build up a some functions to make this
            easier to reason about.

            ```clj
            (defn compose [f g]
              (fn [x] (f (g x))))
            ```

            With that, we can now define

            ```clj
            (defn add [a b]
              (fn [f]
                (compose (a f) (b f))))
            ```

    %data.subsect{:title "Extended Exercise: Interval Arithmetic"}
      %md
        Alyssa P. Hacker is designing a system to help people solve engineering
        problems. One feature she wants to provide in her system is the ability
        to manipulate inexact quantities (such as measured parameters of
        physical devices) with known precision, so that when computations are
        done with such approximate quantities the results will be numbers of
        known precision.

        Electrical engineers will be using Alyssa's system to compute
        electrical quantities. It is sometimes necessary for them to compute
        the value of a parallel equivalent resistance \\(R_p\\) of two
        resistors \\(R_1\\) and \\(R_2\\) using the formula

        $$R_p=\frac{1}{1/R_1+1/R_2}$$

        Resistance values are usually known only up to some tolerance
        guaranteed by the manufacturer of the resistor. For example, if you buy
        a resistor labeled "6.8 ohms with 10% tolerance" you can only be sure
        that the resistor has a resistance between 6.8 - 0.68 = 6.12 and 6.8 +
        0.68 = 7.48 ohms. Thus, if you have a 6.8-ohm 10% resistor in parallel
        with a 4.7-ohm 5% resistor, the resistance of the combination can range
        from about 2.58 ohms (if the two resistors are at the lower bounds) to
        about 2.97 ohms (if the two resistors are at the upper bounds).

        Alyssa's idea is to implement "interval arithmetic" as a set of
        arithmetic operations for combining "intervals" (objects that represent
        the range of possible values of an inexact quantity). The result of
        adding, subtracting, multiplying, or dividing two intervals is itself
        an interval, representing the range of the result.

        Alyssa postulates the existence of an abstract object called an
        "interval" that has two endpoints: a lower bound and an upper bound.
        She also presumes that, given the endpoints of an interval, she can
        construct the interval using the data constructor `make-interval`.
        Alyssa first writes a procedure for adding two intervals. She reasons
        that the minimum value the sum could be is the sum of the two lower
        bounds and the maximum value it could be is the sum of the two upper
        bounds:

        ```clj
        (defn add-interval [x y]
          (make-interval (+ (lower-bound x) (lower-bound y))
                         (+ (upper-bound x) (upper-bound y))))
        ```

        Alyssa also works out the product of two intervals by finding the
        minimum and the maximum of the products of the bounds and using them as
        bounds of the resulting interval. (`min` and `max` are primitives that
        find the minimum and maximum of any number of arguments.)

        ```clj
        (defn mul-interval [x y]
          (let [p1 (* (lower-bound x) (lower-bound y))
                p2 (* (lower-bound x) (upper-bound y))
                p3 (* (upper-bound x) (lower-bound y))
                p4 (* (upper-bound x) (upper-bound y))]
            (make-interval (min p1 p2 p3 p4)
                           (max p1 p2 p3 p4))))
        ```

        To divide two intervals, Alyssa multiplies the first by the reciprocal
        of the second. Note that the bounds of the reciprocal interval are the
        reciprocal of the upper-bound and the reciprocal of the lower-bound, in
        that order.

        ```clj
        (defn div-interval [x y]
          (mul-interval x
                        (make-interval (/ 1.0 (upper-bound y))
                                       (/ 1.0 (lower-bound y)))))
        ```

    %data.exercises
      %data.exercise
        %md
          Alyssa's program is incomplete because she has not specified the
          implementation of the interval abstraction. Here is a definition of
          the interval constructor:

          ```clj
          (defn make-interval [a b]
            (list a b))
          ```

          Define selectors `upper-bound` and `lower-bound` to complete the
          implementation.

        %data.q-a
          %md
            ```clj
            (defn upper-bound [z]
              (second z))
            (defn lower-bound [z]
              (first z))
            ```

      %data.exercise
        %md
          Using reasoning analogous to Alyssa's, describe how the difference of
          two intervals may be computed. Define a corresponding subtraction
          procedure, called `sub-interval`.

        %data.q-a
          %md
            Using reasoning analogous to Alyssa's, we'd define `sub-interval`
            as:

            ```clj
            (defn sub-interval [a b]
              (make-interval (- (lower-bound a) (upper-bound b))
                             (- (upper-bound a) (lower-bound b))))
            ```

      %data.exercise
        %md
          The *width* of an interval is half of the difference between its
          upper and lower bounds. The width is a measure of the uncertainty of
          the number specified by the interval. For some arithmetic operations
          the width of the result of combining two intervals is a function only
          of the widths of the argument intervals. Show that the width of the
          sum (or difference) of two intervals is a function only of the widths
          of the intervals being added (or subtracted). Give examples to show
          that this is not true for multiplication or division.
        
        %data.q-a
          %md
            Let's define two intervals \\(x=(a-\delta,a+\delta)\\), and
            \\(y=(b-\epsilon,b+\epsilon)\\), where \\(\delta,\epsilon\\) are
            positive real numbers (and hence the width of their respective
            intervals). Then, the interval `(add-interval x y)` would be
            \\((a+b-(\epsilon+delta),a+b+(\epsilon+\delta))\\), making the
            width of the sum equal to the sum of the widths.

            Similarly, `(sub-interval a b)` would be,
            
            $$(a-\delta - (b+\epsilon),a+\epsilon-(b-\epsilon))=(a-b-(\delta+\epsilon),a-b+(\delta-\epsilon))$$
              
              making the width of the difference of intervals equal to the
              difference of the widths of the intervals.

            For multiplication, however, things are not as simple. Let's
            consider two pairs of intervals, each pair with the same
            corresponding widths:

            $$a=(0,2), b=(0,2) c=(5,7) d=(5,7)$$

            Since these intervals all have the same width, if the width of the
            product is a function of the widths of the intervals, then the
            product of any two of these intervals should yield an interval with
            the same width. But this is clearly not this case because `(width
            (mul-interval a b))` is 2, but `(width (mul-interval c d))` is 12.
            So clearly the width of the product is not a function of the widths
            alone.

            As for division, we can define \\(a,b=(1,2)\\), and
            \\(c,d=\\((5,6)\\). Then, `(div-interval a b)` is \\((1/2, 2)\\),
            but `(div-interval c d)` is \\((5/6,6/5)\\). The width of the first
            is 0.75 or 3/4, but the width of the second is 11/60.

      %data.exercise
        %md
          Ben Bitdiddle, an expert systems programmer, looks over Alyssa's
          shoulder and comments that it is not clear what it means to divide by
          an interval that spans zero. Modify Alyssa's code to check for this
          condition and to signal an error if it occurs.

        %data.q-a
          %md
            ```clj
            (defn div-interval [a b]
              (let [span-zero? #(> 0
                                   (* (lower-bound %)
                                      (upper-bound %)))]
                (if (span-zero? b)
                    (throw (Exception. "Can't divide by zero!"))
                    (mul-interval a
                                  (make-interval (/ 1.0 (upper-bound b))
                                                 (/ 1.0 (lower-bound b)))))))
            ```

      %data.exercise
        %md
          In passing, Ben also cryptically comments: "By testing the signs of
          the endpoints of the intervals, it is possible to break mul-interval
          into nine cases, only one of which requires more than two
          multiplications." Rewrite this procedure using Ben's suggestion.

        %data.q-a
          %md
            ```clj
            (defn mul-interval [a b]
              (cond (> (lower-bound a) 0)
                    (cond (> (lower-bound b) 0)
                          (make-interval (* (lower-bound a)
                                            (lower-bound b))
                                         (* (upper-bound a)
                                            (upper-bound b)))
                          (> 0 (upper-bound b))
                          (make-interval (* (upper-bound a)
                                            (lower-bound b))
                                         (* (lower-bound a)
                                            (upper-bound b)))
                          :else 
                          (make-interval (* (upper-bound a)
                                            (lower-bound b))
                                         (* (upper-bound a)
                                            (upper-bound b))))
                    (> 0 (upper-bound a))
                    (cond (> (lower-bound b) 0)
                          (make-interval (* (lower-bound a)
                                            (upper-bound b))
                                         (* (upper-bound a)
                                            (lower-bound b)))
                          (> 0 (upper-bound b))
                          (make-interval (* (upper-bound a)
                                            (upper-bound b))
                                         (* (lower-bound a)
                                            (lower-bound b)))
                          :else 
                          (make-interval (* (lower-bound a)
                                            (upper-bound b))
                                         (* (lower-bound a)
                                            (lower-bound b))))
                    :else
                    (cond (> (lower-bound b) 0)
                          (make-interval (* (lower-bound a)
                                            (upper-bound b))
                                         (* (upper-bound a)
                                            (upper-bound b)))
                          (> 0 (upper-bound b))
                          (make-interval (* (upper-bound a)
                                            (lower-bound b))
                                         (* (lower-bound a)
                                            (lower-bound b)))
                          :else 
                          (let [w (* (lower-bound a)
                                     (upper-bound b))
                                x (* (lower-bound a)
                                     (lower-bound b))
                                y (* (upper-bound a)
                                     (upper-bound b))
                                z (* (upper-bound a)
                                     (lower-bound b))]
                            (make-interval (min w x y z)
                                           (max w x y z))))))
            ```

        %md
          After debugging her program, Alyssa shows it to a potential user, who
          complains that her program solves the wrong problem. He wants a
          program that can deal with numbers represented as a center value and
          an additive tolerance; for example, he wants to work with intervals
          such as 3.5± 0.15 rather than [3.35, 3.65]. Alyssa returns to her
          desk and fixes this problem by supplying an alternate constructor and
          alternate selectors:

          ```clj
          (defn make-center-width [c w]
            (make-interval (- c w) (+ c w)))
          (defn center [i]
            (/ (+ (lower-bound i) (upper-bound i)) 2))
          (defn width [i]
            (/ (- (upper-bound i) (lower-bound i)) 2))
          ```

          Unfortunately, most of Alyssa's users are engineers. Real engineering
          situations usually involve measurements with only a small
          uncertainty, measured as the ratio of the width of the interval to
          the midpoint of the interval. Engineers usually specify percentage
          tolerances on the parameters of devices, as in the resistor
          specifications given earlier.

      %data.exercise
        %md
          Define a constructor `make-center-percent` that takes a center and a
          percentage tolerance and produces the desired interval. You must also
          define a selector `percent` that produces the percentage tolerance
          for a given interval. The `center` selector is the same as the one
          above.

        %data.q-a
          %md
            ```clj
            (defn make-center-percent [c p]
              (let [width (* c p)]
                (make-interval (- c width) (+ c width))))
            (defn percent [i]
              (/ (width i) (center i)))
            ```

      %data.exercise
        %md
          Show that under the assumption of small percentage tolerances there
          is a simple formula for the approximate percentage tolerance of the
          product of two intervals in terms of the tolerances of the factors.
          You may simplify the problem by assuming that all numbers are
          positive.

        %data.q-a
          %md
            Let's take two intervals, \\((a-\epsilon,a+\epsilon)\\) and
            \\((b-\delta,b+\delta)\\), where \\(a,b\\) and
            \\(\epsilon,\delta\\) are positive numbers and
            \\(\epsilon,\delta\\) are small. Then, the product is given by,

            $$\begin{align*}&\left((a-\epsilon)(b-\delta),(a+\epsilon)(b+\delta)\right)
            \\\\=&\left(ab-a\delta-b\epsilon+\epsilon\delta,ab+a\delta+b\epsilon+\epsilon\delta\right)
            \\\\=&\left((ab+\epsilon\delta)-(a\delta+b\epsilon),(ab+\epsilon\delta)+(a\delta+b\epsilon)\right)\end{align*}$$

            So, we see that the width in question is, \\(a\delta+b\epsilon\\),
            and the center is \\(ab+\epsilon\delta\\). Hence, the percentage
            tolerance is,

            $$\begin{align*}
            \frac{a\delta+b\epsilon}{ab+\epsilon\delta}\approx& \frac{a\delta
            +b\epsilon}{ab+0} \\\\=&\frac{a\delta+b\epsilon}{ab}
            \\\\=&\frac{\delta}{b}+\frac{\epsilon}{a}\end{align*}$$

            Which is the sum of the respective percentages.

            So, as long as the percentages are small enough for their squares
            to become negligible, the percentage tolerance of a product of
            intervals is sum of the percentage tolerances of the two respective
            intervals.

        %md
          After considerable work, Alyssa P. Hacker delivers her finished
          system. Several years later, after she has forgotten all about it,
          she gets a frenzied call from an irate user, Lem E. Tweakit. It seems
          that Lem has noticed that the formula for parallel resistors can be
          written in two algebraically equivalent ways:

          $$\frac{R_1R_2}{R_1+R_2}$$

          and

          $$\frac{1}{1/R_1+1/R_2}$$

          He has written the following two programs, each of which computes the
          parallel-resistors formula differently:

          ```clj
          (defn par1 [r1 r2]
            (div-interval (mul-interval r1 r2)
                          (add-interval r1 r2)))
          (defn par2 [r1 r2]
            (let [one (make-interval 1 1)]
              (div-interval one
                            (add-interval (div-interval one r1)
                                          (div-interval one r2)))))
          ```

          Lem complains that Alyssa's program gives different answers for the
          two ways of computing. This is a serious complaint.

      %data.exercise
        %md
          Demonstrate that Lem is right. Investigate the behavior of the system
          on a variety of arithmetic expressions. Make some intervals A and B,
          and use them in computing the expressions A/A and A/B. You will get
          the most insight by using intervals whose width is a small percentage
          of the center value. Examine the results of the computation in
          center-percent form (see [exercise 2.12](#!/sicp/ch/2/ex/12/)).

        %data.q-a
          %md
            If we define \\(A=(29.9,30.1)\\), and \\(B=(49.9,51.1)\\), what
            happens when we divide \\(A\\) by itself? \\(B\\) by itself?
            \\(A\\) by \\(B\\)? \\(B\\) by \\(A\\)?

      %data.exercise
        %md
          Eva Lu Ator, another user, has also noticed the different intervals
          computed by different but algebraically equivalent expressions. She
          says that a formula to compute with intervals using Alyssa's system
          will produce tighter error bounds if it can be written in such a form
          that no variable that represents an uncertain number is repeated.
          Thus, she says, `par2` is a "better" program for parallel resistances
          than `par1`. Is she right? Why?

        %data.q-a
          %md
            She is correct. The reason is, if we write an equation,
            \\(\frac{x+1}{x}\\), for instance, the assumption is that both
            \\(x\\)s in the equation have the same value. If we do this with
            the interval arithmetic we've defined here, that is not necessarily
            true. ie, if we define \\(A=(2,4)\\) then compute the above formula
            using our interval arithmetic assuming that \\(x\\) is in the
            interval \\(A\\), we get

            $$\begin{align*}
            \frac{A+1}{A}=&\frac{(3,5)}{(2.4)}
            \end{align*}$$

            which is another way of saying, "the interval obtained by taking
            any number between 3 and 5 and dividing it by another number
            between 2 and 4." But then, 3/4, for instance, would be in that
            interval by letting the numerator be 3 and the denominator be 4.
            But the problem is, if the numerator is to be 4, then \\(x=2\\),
            which means the denominator would be 2 as well.

            The issue we're arriving at is that different instances of the same
            variable can have different values (if we use our current system of
            interval arithmetic).

      %data.exercise
        %md
          Explain, in general, why equivalent algebraic expressions may lead to
          different answers. Can you devise an interval-arithmetic package that
          does not have this shortcoming, or is this task impossible? (Warning:
          This problem is very difficult.)

        %data.q-a
          %md
            I guess this would depend on what we mean by "equivalent". Already
            due to what we've seen in [exercise 2.15](#!/sicp/ch/1/ex/15/),
            very strange things happen algebraically. For instance, our
            interval arithmetic does not have the distributive property. To
            show this, just observe that the distributive property states,
            \\(A(B+C)=AB+AC\\), but since \\(A\\) appears twice on the right
            hand side and there are no repeated variables on the left, by the
            previous exercise we know that the left hand side must have
            "tighter error bounds". Hence the two sides cannot be equal unless
            there is no error in \\(A\\) (in which case \\(A\\) is not an
            interval, but a number).

            So, I'm not too sure if this is possible, but when would we use
            this? If it is an engineering (or scientific) concern, then we are
            not really interested in intervals, but rather statistical
            probabilities, in which case we can use some theorems about error
            propagation to achieve our goal.
